package controllers

import (
	"bufio"
	"expdb/db/sqlite"
	"expdb/models"
	"fmt"
	"net/http"
	"os"
	"strconv"

	"github.com/gin-gonic/gin"
)

func IndexGetHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.HTML(http.StatusOK, "index.html", nil)
	}
}

func ExploitsGetHandler(db *sqlite.Storage) gin.HandlerFunc {
	return func(c *gin.Context) {
		db, err := db.StorageAsSlice()

		if err != nil {
			panic(http.StatusBadRequest)
		}

		c.HTML(http.StatusOK, "exploits.html", gin.H{
			"exploits": db,
		})
	}
}

func ExploitsPostHandler(db *sqlite.Storage) gin.HandlerFunc {
	return func(c *gin.Context) {
		var exploit models.Exploit

		bindJson(&exploit, c)

		if err := db.Insert(&exploit); err != nil {
			fmt.Println(fmt.Errorf("can't insert exploit to database: %w", err).Error())
		}

		c.IndentedJSON(http.StatusCreated, exploit)
	}
}

func ExploitsRemoveHandler(db *sqlite.Storage) gin.HandlerFunc {
	return func(c *gin.Context) {
		var exploit models.Exploit

		bindJson(&exploit, c)

		if err := db.Remove(&exploit); err != nil {
			fmt.Println(fmt.Errorf("can't delete exploit from database: %w", err).Error())
		}

		c.IndentedJSON(http.StatusCreated, exploit)

	}
}

func ExploitsGetByIdHandler(db *sqlite.Storage) gin.HandlerFunc {
	return func(c *gin.Context) {
		id := c.Param("id")
		intId, _ := strconv.Atoi(id)

		content, err := readRawFromTxt(`C:\Users\USER\Desktop\expRaws\`, id)
		if err != err {
			fmt.Println(fmt.Errorf("can't read file: %w", err).Error())
		}

		exploit, err := db.GetById(intId)
		if err != nil {
			fmt.Println(fmt.Errorf("can't get exploit by id: %w", err).Error())
		}

		if exploit == nil {
			c.JSON(http.StatusNotFound, gin.H{
				"code":    http.StatusNotFound,
				"message": "Page not found",
			})
		} else {
			c.HTML(http.StatusFound, "exploit.html", gin.H{
				"title":    exploit.Title,
				"date":     exploit.Date,
				"type":     exploit.Type,
				"platform": exploit.Platform,

				"link": "http://localhost:8080/raw/" + id,
				"raw":  content,
			})
		}
	}
}

func RawGetHandler(db *sqlite.Storage) gin.HandlerFunc {
	return func(c *gin.Context) {
		id := c.Param("id")

		content, err := readRawFromTxt(`C:\Users\USER\Desktop\expRaws\`, id)
		if err != err {
			fmt.Println(fmt.Errorf("can't read file: %w", err).Error())
		}

		if content == nil {
			c.JSON(http.StatusNotFound, gin.H{
				"code":    http.StatusNotFound,
				"message": "Page not found",
			})
		} else {
			c.IndentedJSON(http.StatusOK, content)
		}
	}
}

func readRawFromTxt(path, filename string) ([]string, error) {
	file, err := os.Open(path + filename + ".txt")
	if err != nil {
		return nil, err
	}

	defer func() {
		if err = file.Close(); err != nil {
			fmt.Println(fmt.Errorf("can't close file: %w", err).Error())
		}
	}()

	scanner := bufio.NewScanner(file)
	var raw []string
	for scanner.Scan() {
		raw = append(raw, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return raw, nil
}

func bindJson(exploit *models.Exploit, c *gin.Context) {
	if err := c.BindJSON(&exploit); err != nil {
		fmt.Println(fmt.Errorf("can't bind json: %w", err).Error())
	}
}
